---
title: 'Supplemental Material for _Complementarity in Alliances: How strategic compatibility and hierarchy promote efficient cooperation in international security_'
author:
  - name: J Andrés Gannon
format:
  pdf:
    fig-format: png
    toc: false
    number-sections: false
    keep-tex: true
editor: source
execute:
  echo: false
  warning: false
  cache: true
header-includes:
- \usepackage{tikz}
- \usepackage{pgfplots}
- \pgfplotsset{compat=newest}
- \usetikzlibrary{plotmarks}
- \usetikzlibrary{arrows.meta}
- \usepgfplotslibrary{patchplots}
- \usepackage{grffile}
- \usepackage{caption}
- \usepackage[utf8]{inputenc}
- \usepackage{float}
- \usepackage{multirow}
- \usepackage{tablefootnote}
- \usepackage{pifont}
- \usepackage{newunicodechar}
- \usepackage{booktabs}
- \usepackage{siunitx}
- \usepackage{tabularx}
- \newunicodechar{✓}{\ding{51}}
- \usepackage{tabularray}
- \usepackage{float}
- \floatplacement{table}{H}
- \usepackage{graphicx}
- \usepackage{codehigh}
- \usepackage[normalem]{ulem}
- \UseTblrLibrary{booktabs}
- \UseTblrLibrary{siunitx}
- \newcommand{\beginsupplement}{
    \setcounter{table}{0}  
    \renewcommand{\thetable}{A\arabic{table}} 
    \setcounter{figure}{0} 
    \renewcommand{\thefigure}{A\arabic{figure}}}
bibliography: rDMC-bib.bib
---

```{r knitr-options, cache = FALSE}
library(knitr)
library(kableExtra)
library(ggplot2)
library(ggtext)
options(mc.cores = parallel::detectCores())
```

```{r load data}
df_raw <- readRDS(file = paste0(here::here(), "/data/rDMC_raw_v1.rds"))
df_long <- readRDS(file = paste0(here::here(), "/data/rDMC_long_v1.rds"))
df_wide <- readRDS(file = paste0(here::here(), "/data/rDMC_wide_v1.rds"))

df <- readRDS(file = paste0(here::here(), "/data/03_df-full.rds"))
```

\beginsupplement

\tableofcontents

\newpage

# A. Descriptive statistics

```{r summstats}
#| label: tbl-summstats
#| tbl-cap: "Summary statistics of model variables. Year polynomials omitted from table."
#| tbl-position: H

df |>
  dplyr::select('Year' = year,
                'Division of labor' = dol_nicheolap,
                'Strategic compatibility' = strcomp_cinc_total_scaled,
                'Hierarchy' = hier_laplace_scaled,
                'Peacetime coordination' = milinst,
                'Democracy ratio' = demo_polityprop,
                'Proportion contiguous' = dist_contigprop,
                'Maximum distance (log)' = dist_maxlog,
                'Number of rivals (log)' = rivals_log,
                'Alliance members (log)' = members_log,
                'Alliance age (avg)' = allianceage_avg) |>
  modelsummary::datasummary_skim(Title = "Summary statistics of model variables",
                                 histogram = FALSE,
                                 fmt = 2,
                                 output = "tinytable") |>
  tinytable::theme_tt("resize")
```

```{r}
miss_top_case <- df |>
  dplyr::select(year, atopid, dol_nicheolap) |>
  dplyr::summarise(sum_na = sum(is.na(dol_nicheolap)), .by = atopid) |>
  dplyr::arrange(-sum_na) |>
  dplyr::pull(atopid) |>
  dplyr::first()

miss_top_count <- df |>
  dplyr::select(year, atopid, dol_nicheolap) |>
  dplyr::summarise(sum_na = sum(is.na(dol_nicheolap)), .by = atopid) |>
  dplyr::arrange(-sum_na) |>
  dplyr::pull(sum_na) |>
  dplyr::first()

miss_second_case <- df |>
  dplyr::select(year, atopid, dol_nicheolap) |>
  dplyr::summarise(sum_na = sum(is.na(dol_nicheolap)), .by = atopid) |>
  dplyr::arrange(-sum_na) |>
  dplyr::pull(atopid) |>
  dplyr::nth(2)

miss_second_count <- df |>
  dplyr::select(year, atopid, dol_nicheolap) |>
  dplyr::summarise(sum_na = sum(is.na(dol_nicheolap)), .by = atopid) |>
  dplyr::arrange(-sum_na) |>
  dplyr::pull(sum_na) |>
  dplyr::nth(2)
```

Most of the missing data comes from the division of labor variable and is primarily due to two alliances for which there are many missing values -- ATOP ID `r miss_top_case` (bilateral defense pact between France and Comoros signed in 1978) is missing `r miss_top_count` values and ATOP ID `r miss_second_case` (treaty establishing the Organization of Eastern Caribbean States between Antigua, Dominica, Grenada, Montserrat, St. Kitts/Nevis, Saint Lucia, and St. Vincent and the Grenadines) is missing `r miss_second_count`.

\newpage

# B. Manuscript model supplementary info

## Ordered beta results table

```{r}
#| results: hide

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

m1_obr <- ordbetareg::ordbetareg(dv ~ 
                                   strcomp + hier + 
                                   milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg +
                                   (1 | year_norm),
                                 data = df_m1,
                                 cores = 6,
                                 chains = 6,
                                 iter = 2000,
                                 backend = "cmdstanr",
                                 refresh = 0,
                                 file = "ordbeta",
                                 file_refit = "on_change")
```

```{r}
#| label: tbl-obr
#| tbl-cap: "Log odds coefficient estimates. Time dependencies modeled as year cubic splines given computational constraints for year fixed effects."
#| fig.position: 'H'

coefs <- c("b_strcomp" = "Strategic Compatibility",
           "b_hier" = "Hierarchy",
           "b_milinst" = "Peacetime Coordination",
           "b_demo_polityprop" = "Democracy Ratio",
           "b_dist_contigprop" = "Contiguity Ratio",
           "b_dist_maxlog" = "Maximum Distance (log)",
           "b_rivals_log" = "Number of Rivals (log)",
           "b_members_log" = "Number of Members (log)",
           "b_allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(m1_obr,
                           statistic = "conf.int",
                           exponentiate = TRUE,
                           coef_map = coefs,
                           coef_omit = "Intercept",
                           metrics = "RMSE",
                           output = "tinytable")

# marginaleffects::plot_predictions(m1_obr, condition = "strcomp")
# marginaleffects::plot_predictions(m1_obr, condition = "hier")
```

\newpage

# C. Alternate explanatory variables

## Strategic Compatibility

I define strategic compatibility as "consistency of states' security interests and agreement on the nature of the international threat environment". To provide more detail, including exact definitions from the original data sources, state B is considered a part of state A's threat environment if it meets any of the following conditions:

1)  Strategic rivalry - states A and B have an un-directed strategic rivalry if they "regard each other as (a) competitors, (b) the source of actual or latent threats that pose some possibility of becoming militarized, and (c) enemies" [@thompson_identifyingrivalsrivalries_2001, 560]. The data comes from @thompson_analyzingstrategicrivalries_2021 [34-46] and codings are used without modification.

2)  Peace scale rivalry - states A and B have an un-directed peace scale relationship coded as "severe rivalry", meaning "the states see one another as enemies and competitors...which encourage rivals to handle their contested issues via frequent and intense uses of violence." or states A and B are non-allied and have an un-directed peace scale relationship coded as "lesser rivalry", meaning that "The sentiments of threat, enmity and competition that remain—along with the persistence of unresolved issues—mean that lesser rivalries still experience isolated violent episodes (e.g. militarized disputes or MIDs), diplomatic hostility, and non-violent crises" [@diehl_peacedataconcept_2021, 610]. I use version 3.1.

3)  Politically relevant threat environment - state B is contiguous or a great power *and* it is non-allied with a kappa chance-corrected alliance similarity score below the population median. Contiguity and great power status are a commonly used scope condition for politically relevant dyads [@maoz_domesticsourcesglobal_1996, 168] and the decision to subset that to dyads with inconsistent foreign policy orientations comes from @leeds_terminatingallianceswhy_2007. The modifications I make relative to @leeds_terminatingallianceswhy_2007 concern expanding the definition of contiguous to include less than 25 miles of water [@benson_relevancepoliticallyrelevant_2005; @bennett_exploringoperationalizationspolitical_2006; @braumoeller_politicalirrelevancedemocracy_2011] and instead of using the population's median s-score as a threshold for similar foreign policy orientation, I use the kappa chance-corrected measure to minimize statistical bias in s-score comparisons [@cohen_coefficientagreementnominal_1960; @hage_choicecircumstanceadjusting_2011; @chiba_carefulcommitmentsdemocratic_2015].

```{r}
dyad_threat <- readRDS(file = paste0(here::here(), '/data/dyad_threat.rds')) |>
  dplyr::mutate(rival_peace = dplyr::if_else(peacelevel < 0.25 | (peacelevel == 0.25 & atop_defense_type == "none"), 1, 0),
                rival_prd = dplyr::if_else(prd_threat == 1 & sscore_below == 1 & atop_defense_type == "none", 1, 0)) |>
  dplyr::mutate(rival_strat = dplyr::if_else(rival_strat == 1, dplyr::row_number(), NA),
                rival_peace = dplyr::if_else(rival_peace == 1, dplyr::row_number(), NA),
                rival_prd = dplyr::if_else(rival_prd == 1, dplyr::row_number(), NA))
```

There are `{r} nrow(dyad_threat) |> scales::comma()` directed-dyad years from 1970 to 2014 of which `{r} dyad_threat |> dplyr::filter(threatenviro == 1) |> nrow() |> scales::comma()` categorize state B as being a member of state A's threat environment. @fig-strcompcompare shows the overlap among the 3 criteria used to determine each state's threat environment.

```{r}
#| label: fig-strcompcompare
#| fig-cap: "Overlap among strategic compatibility criteria. Counts refer to number of dyad-years."
#| fig.position: H

ggVennDiagram::ggVennDiagram(list('(1) Strategic rival' = dyad_threat$rival_strat,
                                  '(2) Peace scale rival' = dyad_threat$rival_peace,
                                  '(3) Politically relevant threat environment' = dyad_threat$rival_prd),
                             set_color = c("#1B9E77", "#D95F02", "#7570B3"),
                             label_percent_digit = 1,
                             label_size = 3.5) +
  scale_fill_distiller(palette = "Purples", direction = 1) +
  scale_color_brewer(palette = "Dark2") +
  labs(title = "Dyad-years per strategic compatibility criteria") +
  scale_x_continuous(expand = expansion(mult = .3)) +
  theme(legend.position = "none")
```

Criteria 1 is most similar to @poast_arguingalliancesart_2019[52-57] and Criteria 3 is most similar to @leeds_terminatingallianceswhy_2007 [1127] with the following modifications:

-   @poast_arguingalliancesart_2019 uses a count of states as threats, while I weight each threat by their CINC score. If all NATO states view Russia as a threat and only the US views Cuba as a threat, the relative military salience of Russia and Cuba should be considered.

-   @poast_arguingalliancesart_2019 [93] addresses the absence of asymmetric rivalries in @thompson_identifyingrivalsrivalries_2001 by adding contiguous great powers as a strategic rival. I address that through Criteria 3 in my measure.

-   @poast_arguingalliancesart_2019 makes strategic compatibility binary with high (low) strategic compatibility being above (below) the sample median, I keep it continuous and scale it by the highest observed value in the full population.

-   @poast_arguingalliancesart_2019 combines strategic compatibility (what I measure) with operational compatibility which addresses agreement about how to use military force against a threat based on offensive or defense war time doctrine [@bennett_durationinterstatewars_1996; @stam_winlosedraw_1996; @reiter_democracywarinitiation_1998]. I do not include a measure of operational compatibility given its similarity to the dependent variable, lack of vary within alliances, and absence of data for my time period.

-   @leeds_terminatingallianceswhy_2007 use un-weighted ATOP s-score, but I use the kappa-corrected s-score measure as suggested by [@hage_choicecircumstanceadjusting_2011; @cohen_coefficientagreementnominal_1960].

-   @leeds_terminatingallianceswhy_2007 exclude all alliance partners from a state's threat environment. Since allies do sometimes have serious rivalries and conflicts (Greece-Turkey in NATO, India-Pakistan in SCO, Russia-Georgia, Russia-Ukraine, Armenia-Azerbaijan in CIS, etc) I allow an ally to be in your threat environment if it is coded as a strategic rivalry or a peace level "serious rivalry" [@weitsman_intimateenemiespolitics_1997; @bearce_alliancesinternalinformation_2006].

I find consistent results using weighted and un-weighted s-scores measuring alliance portfolio similarity using ATOP which has previously been used to measure variation in strength of alliance ties [@gibler_priorcommitmentscompatible_2004; @chiba_carefulcommitmentsdemocratic_2015; @fordham_allalliancesare_2016]. I opt against using UN voting similarity as a measure of strategic compatibility because of recognized problems with chance agreement [@hage_choicecircumstanceadjusting_2011] the high frequency of consensus decisions [@hage_consensusdecisionssimilarity_2016], and agenda effects bias year-over-year change [@bailey_estimatingdynamicstate_2017].

```{r}
#| label: tbl-altstrcomp
#| tbl-cap: "Coefficient estimates with alternate variables for strategic compatibility."
#| tbl.position: H

atop_sscore <- rio::import(paste0(here::here(), "/inst/extdata/ATOP/atop-sscore.csv")) |>
  dplyr::filter(year >= 1970) |>
  dplyr::select(year, ccode1, ccode2, s_un_atop, s_wt_atop, kappa_atop, pi_atop)

atop_cy <- rio::import(paste0(here::here(), "/inst/extdata/ATOP/atop5_1m.csv")) %>%
  dplyr::filter(yrexit > 1970 |
                  yrexit == 0) %>%
  dplyr::mutate(yrexit = dplyr::if_else(yrexit == 0,
                                        2023,
                                        yrexit)) %>%
  dplyr::select(atopid, member, yrent, yrexit) %>%
  dplyr::distinct() %>%
  dplyr::mutate(row = dplyr::row_number()) %>%
  dplyr::group_by(row, atopid, member) %>%
  dplyr::reframe(year = seq(yrent, yrexit)) %>%
  dplyr::ungroup() %>%
  dplyr::select(-row) %>%
  dplyr::rename(ccode1 = 'member') %>%
  dplyr::filter(year %in% c(1970:2014))

atop_sscoreagg <- dplyr::left_join(atop_cy, atop_sscore) %>%
  dplyr::summarise(strcomp_atopunw = mean(s_un_atop),
                   strcomp_atopwt = mean(s_wt_atop),
                   strcomp_atopkappa = mean(kappa_atop),
                   strcomp_atoppi = mean(pi_atop),
                   .by = c(atopid, year)) %>%
  dplyr::mutate(atopid = as.character(atopid),
                year = as.numeric(year))

df_m1 <- df %>%
  dplyr::mutate(atopid = as.character(atopid)) %>%
  dplyr::left_join(., atop_sscoreagg) %>%
  dplyr::mutate(atopid = as.factor(atopid)) %>%
  dplyr::rename(dv = dol_nicheolap,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp_atopwt + hier + 
                               demo_polityprop + dist_contigprop + dist_maxlog + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp_atopunw + hier + 
                               demo_polityprop + dist_contigprop + dist_maxlog + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1))

coefs <- c("strcomp_atopwt" = "S-score (weighted)",
           "strcomp_atopunw" = "S-score (unweighted)",
           "hier" = "Hierarchy",
#           "milinst" = "Peacetime Coordination",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
#           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept", 
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance-clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::theme_tt("resize")
```

\newpage

## Hierarchy

Alliance power asymmetry has been measured using a variety of similar measures. While none are identical to the new measure of hierarchy created, one would still expect the coefficient sign to be consistent. These measures are defined in the original texts as follows:

-   potential military capacity [@benson_assessingvariationformal_2016, 873-875]: log of the summed CINC score of all alliance members, presence of a major power, mean geographic distance between all alliance pairs, log of the number of alliance members, mean s-score of all pairs of alliance members, and the average Polity IV score of all alliance members.

-   alliance depth [@benson_assessingvariationformal_2016, 872-873]: "military contact, common defense policy, integrated command, military aid, military basing, specific contribution, organization, economic aid, and secret."

-   peacetime coordination [@leeds_allianceinstitutionalizationalliance_2005, 188-191]: ordinal variable coded *high* if alliances have an integrated military command during peacetime and wartime, have a common defense policy obligation, and have joint troop placement agreements. Coded *moderate* if peacetime official military contact is required, there is a formal military organization for coordination, one party is required to provide training or technology to another, and there are specific plans to subordinate one military to another during conflict. Coded *low* otherwise.

-   latent alliance depth [@alley_allianceparticipationtreaty_2021, 932]: ordinal factor analysis measuring "additional policy coordination and military cooperation beyond a promise of military support. Defense cooperation in a deep alliance can take many forms, including an integrated military command, military aid, common defense policies, basing rights, international organizations, specific contribution requirements or companion military agreements."

-   CINC dispersion [@gibler_priorcommitmentscompatible_2004, 316]: "captures the dispersal of capabilities in an alliance; it ranges from 0 (when the capabilities in the alliance are equally distributed) to 1 (when one state holds all of the capabilities in the alliance). In this formula, $\sqrt{\sum_{i=1}^{n}(Si)^2-\frac{1}{n}/(1-\frac{1}{n})}$, $Si$ denotes $i$’s share of the alliance’s total capabilities, and $n$ is the number of allies in the alliance."

-   CINC asymmetry [@benson_assessingvariationformal_2016, 888]: "measured by subtracting the CINC scores of the strongest and weakest pair of alliance members."

-   great power participation [@gibler_priorcommitmentscompatible_2004; @leeds_terminatingallianceswhy_2007, 188]: Ratio variable indicating how many alliance members are great powers.

```{r}
#| label: tbl-althierarchy
#| tbl-cap: "Coefficient estimates with alternate variables for hierarchy."
#| tbl.position: H

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp + PotMilCapacity.score + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + Depth.score + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + milinst + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + latent.depth.mean + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + cinc_dispersal + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + cinc_asymmetry + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + gp_ratio + 
                               demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1))

coefs <- c("strcomp" = "Strategic Compatibility",
           "PotMilCapacity.score" = "Potential Military Capacity",
           "Depth.score" = "Alliance Depth",
           "milinst" = "Peacetime Coord",
           "latent.depth.mean" = "Latent Depth",
           "cinc_dispersal" = "CINC Dispersal",
           "cinc_asymmetry" = "CINC Asymmetry",
           "gp_ratio" = "Great power ratio",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept", 
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance-clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::theme_tt("resize")
```

\newpage

## Interaction term

```{r}
#| label: tbl-interaction
#| tbl-cap: "Coefficient estimates with interaction term."
#| tbl.position: H

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ strcomp + hier + 
                               strcomp * hier +
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ strcomp + hier + 
                               strcomp * hier +
                               milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ strcomp + hier +
                               strcomp * hier
                             | year_norm, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ strcomp + hier + 
                               strcomp * hier +
                               milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg 
                             | year_norm, 
                             cluster = "atopid", 
                             data = df_m1),
               lmerTest::lmer(dv ~ strcomp + hier +
                               strcomp * hier +
                                (1 | year_norm),
                              data = df_m1),
               lmerTest::lmer(dv ~ strcomp + hier + 
                               strcomp * hier +
                                milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg +
                                (1 | year_norm),
                              data = df_m1))

coefs <- c("strcomp" = "Strategic Compatibility",
           "hier" = "Hierarchy",
           "strcomp:hier" = "Strat Comp*Hierarchy",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models,
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept",
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::group_tt(j = list("Year Polynomials" = 2:3, "Year FE" = 4:5, "Multilevel Model" = 6:7)) |>
  tinytable::theme_tt("resize")


# marginaleffects::plot_predictions(m1_obr, condition = c("strcomp", "hier"))
```

```{r}
#| eval: false

# Bayesian model with interaction term
# https://bookdown.org/connect/#/apps/1850/access

brms::brm(dv ~ 
            strcomp + hier + 
            strcomp:hier + 
            milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg +
            (1 | year_norm),
          data = df_m1, family = gaussian,
          control = list(adapt_delta = 0.9),
          iter = 2000, warmup = 1000, cores = 4, chains = 4) |>
  brms::posterior_summary() |> 
  round(digits = 2)
```

\newpage

# D. Alternate and additional controls

## Alternate controls for democracy

The models in the manuscript operationalize democracy as the proportion of alliance members that have a Polity score greater than 6. The results are robust to other operationalizations of regime type commonly used in the literature like average Polity score [@benson_assessingvariationformal_2016], lowest Polity score based on the "weakest link" principle [@oneal_classicalliberalswere_1997; @fordham_allalliancesare_2016], largest difference in Polity scores [@gibler_priorcommitmentscompatible_2004; @fordham_allalliancesare_2016], and whether all members are of the same regime type. To address missingness in Polity data, I also includes controls using the @marquez_quickmethodextending_2016 extension of the UDS latent variable measure [@pemstein_democraticcompromiselatent_2017].

```{r}
#| label: tbl-altdemo
#| tbl-cap: "Coefficient estimates with alternate democracy variables."
#| tbl.position: H

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_polityavg + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_politylowest + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_politydiff + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_sameregime + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_udsavg + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_udslowest + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               demo_udsdiff + milinst + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1))

coefs <- c("strcomp" = "Strategic Compatibility",
           "hier" = "Hierarchy",
           "demo_polityprop" = "Democracy Ratio",
           "demo_polityavg" = "Polity (avg)",
           "demo_politylowest" = "Polity (lowest)",
           "demo_politydiff" = "Polity (difference)",
           "demo_sameregime" = "Same regime type",
           "demo_udsavg" = "UDS (avg)",
           "demo_udslowest" = "UDS (lowest)",
           "demo_udsdiff" = "UDS (difference)",
           "milinst" = "Peacetime Coordination",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept",
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance-clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::theme_tt("resize")
```

\newpage

## Alternate controls for geography

Instead of the maximum alliance-dyad distance, @bak_allianceproximityeffectiveness_2018 measures the logged mean capital-to-capital distance between all alliance-dyads, treating contiguous states as distance = 0. Model (1) uses @bak_allianceproximityeffectiveness_2018' distance measure exclusively and Model (2) uses it as a replacement for maximum distance.

```{r}
#| label: tbl-altgeog
#| tbl-cap: "Coefficient estimates with alternate geography variables."
#| tbl.position: H

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp + hier + 
                               milinst + demo_polityprop + dist_avglog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               milinst + demo_polityprop + dist_contigprop + dist_avglog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1))

coefs <- c("strcomp" = "Strategic Compatibility",
           "hier" = "Hierarchy",
           "milinst" = "Peacetime Coordination",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Max Distance (log)",
           "dist_avglog" = "Mean Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept",
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance-clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::theme_tt("resize")
```

## Additional controls for NATO, US, and Cold War

```{r}
#| label: tbl-morectrls
#| tbl-cap: "Coefficient estimates with additional control variables."
#| tbl.position: H

country_year <- rio::import(paste0(here::here(), "/inst/extdata/ATOP/atop5_1m.csv")) %>%
  dplyr::filter(yrexit > 1970 |
                  yrexit == 0) %>%
  dplyr::mutate(yrexit = dplyr::if_else(yrexit == 0,
                                        2023,
                                        yrexit)) %>%
  dplyr::select(atopid, member, yrent, yrexit) %>%
  dplyr::distinct() %>%
  dplyr::mutate(row = dplyr::row_number()) %>%
  dplyr::group_by(row, atopid, member) %>%
  dplyr::reframe(year = seq(yrent, yrexit)) %>%
  dplyr::ungroup() %>%
  dplyr::select(-row) %>%
  dplyr::rename(ccode = 'member') %>%
  dplyr::filter(year %in% c(1970:2014)) |>
  dplyr::filter(ccode == 2) |>
  dplyr::mutate(us = 1) |>
  dplyr::select(atopid, year, us) |>
  dplyr::mutate(atopid = as.factor(atopid)) |>
  dplyr::distinct()

df_m1 <- df %>%
  dplyr::left_join(., country_year) |>
  dplyr::mutate(natowp = dplyr::if_else(atopid %in% c(3180, 3285), 1, 0),
                us = tidyr::replace_na(us, 0),
                coldwar = dplyr::if_else(year <= 1989, 1, 0)) |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp + hier + 
                               natowp + milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               us + milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               coldwar + milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + 
                               year_norm + year_sq + year_cube, 
                             cluster = "atopid", 
                             data = df_m1))

# fixest::feols(dv ~ strcomp + hier + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + year_norm + year_sq + year_cube, cluster = "atopid", split = ~ coldwar, data = df_m1)

coefs <- c("strcomp" = "Strategic Compatibility",
           "hier" = "Hierarchy",
           "milinst" = "Peacetime Coordination",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)",
           "natowp" = "NATO/Warsaw Pact",
           "us" = "United States member",
           "coldwar" = "Cold War")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept", 
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models include alliance-clustered standard errors.'),
                           output = "tinytable") |>
  tinytable::theme_tt("resize")
```

\newpage

# E. Other model specifications

## Panel-corrected standard errors

```{r}
#| label: tbl-pcse
#| tbl-cap: "Coefficient estimates using panel-corrected standard errors."
#| tbl.position: H

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled)

models <- list(fixest::feols(dv ~ 
                               strcomp + hier + 
                               year_norm + year_sq + year_cube, 
                             cluster = c("atopid", "year"), 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier + 
                               milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg + year_norm + year_sq + year_cube, 
                             cluster = c("atopid", "year"), 
                             data = df_m1),
               fixest::feols(dv ~ 
                               strcomp + hier | 
                               year_norm, 
                             cluster = c("atopid", "year"), 
                             data = df_m1),
               fixest::feols(dv ~ strcomp + hier + 
                               milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg 
                             | year_norm, 
                             cluster = c("atopid", "year"), 
                             data = df_m1))

coefs <- c("strcomp" = "Strategic Compatibility",
           "hier" = "Hierarchy",
           "milinst" = "Peacetime Coordination",
           "demo_polityprop" = "Democracy Ratio",
           "dist_contigprop" = "Contiguity Ratio",
           "dist_maxlog" = "Maximum Distance (log)",
           "rivals_log" = "Number of Rivals (log)",
           "members_log" = "Number of Members (log)",
           "allianceage_avg" = "Alliance Age (avg)")

modelsummary::modelsummary(models, 
                           stars = c('*' = .05, '**' = .01, '***' = 0.001),
                           coef_map = coefs,
                           coef_omit = "Intercept", 
                           gof_map = c("nobs", "r.squared", 'adj.r.squared', 'aic', 'bic', 'rmse'),
                           notes = list('All models cluster standard errors by alliance and year.'),
                           output = "tinytable") |>
  tinytable::group_tt(j = list("Year Polynomials" = 2:3, "Year Fixed Effects" = 4:5)) |>
  tinytable::theme_tt("resize")
```

\newpage

## Bayesian multi-level model

A Bayesian multi-level model produces posterior distributions for the expected division of labor conditional on strategic compatibility and hierarchy [@burkner_brmspackagebayesian_2017]. Since alliances may differ in both the baseline expectation for the dependent variable as well as how they change over time, a Bayesian multi-level model accounts for alliance-level heterogeneity by allowing a random intercept and slope for each alliance nested within each year [@shor_bayesianmultilevelmodeling_2007]. As a result, alliance-specific deviations from the population average caused by things like alliance design or treaty depth are accounted for.

@fig-bayesmlm shows the results of the model run on 4 MCMC chains with 4,000 iterations per chain. The marginal trend is calculated for each independent variable conditional on the random effects of each alliance. In these results, strategic compatibility has a strong positive association with division of labor where the model results suggest greater than a 95% probability that the true marginal effect is greater than 0. The same is true for hierarchy.

```{r}
#| results: hide

options(mc.cores = 6, brms.backend = "cmdstanr")
bayes_seed <- 1234

df_m1 <- df |>
  dplyr::rename(dv = dol_nicheolap,
                strcomp = strcomp_cinc_total_scaled,
                hier = hier_laplace_scaled) |>
  dplyr::mutate(atopid = as.factor(atopid))

mlm_full <- brms::brm(brms::bf(dv ~ 
                                 strcomp + hier + 
                                 milinst + demo_polityprop + dist_contigprop + dist_maxlog + rivals_log + members_log + allianceage_avg +
                                 (1 + year_norm | atopid),
                                  decomp = "QR"),
                         data = df_m1,
                         chains = 4, seed = bayes_seed, iter = 4000, threads = brms::threading(2))

# bayestestR::diagnostic_posterior(mlm_full) want an R-hat as close to 1 as possible. If above 1.05 model probably didn't converge
```

::: {#fig-bayesmlm layout="[[ 50, 50 ]]"}
```{r}
#| label: fig-bayesmlm-strcomp
#| fig-cap: "Strategic Compatibility"
#| fig-position: H

mlm_full |> 
  emmeans::emtrends(~ 1,
                    var = "strcomp",
                    at = list(year_norm = 0),
                    epred = TRUE, re_formula = NULL) |>
  tidybayes::gather_emmeans_draws() |>
  ggplot(aes(x = .value)) +
  ggdist::stat_halfeye(fill = ggokabeito::palette_okabe_ito(5),
                       .width = c(0.95)) +
  geom_vline(xintercept = 0) +
  theme_bw() +
  labs(x = "Average marginal effect", 
       y = "Density")
```

```{r}
#| label: fig-bayesmlm-hier
#| results: hide
#| fig-cap: "Hierarchy"
#| fig-position: H

mlm_full |>
  emmeans::emtrends(~ 1,
                    var = "hier",
                    at = list(year_norm = 0),
                    epred = TRUE, re_formula = NULL) |>
  tidybayes::gather_emmeans_draws() |>
  ggplot(aes(x = .value)) +
  ggdist::stat_halfeye(fill = ggokabeito::palette_okabe_ito(5),
                       .width = c(0.95)) +
  geom_vline(xintercept = 0) +
  theme_bw() +
  labs(x = "Average marginal effect", 
       y = "Density")
```

Average marginal effect on division of labor of a one standard deviation increase in the independent variables. Point estimates centered at the median value with 0.95 credible intervals. Note x-axes are not fixed.
:::

\newpage

## Double/debiased Machine-learning

Double machine-learning is designed to solve the problem of omitted variable bias by using the residuals of the control variables and independent variables to separately predict the dependent variable then splitting the sample by cross-fitting [@bach_doublemlobjectorientedimplementation_2024].[^1] @tbl-dml show the results, which are consistent with the original estimates.

[^1]: Because this model can only operate on complete cases, I use the UDS democracy score [@marquez_quickmethodextending_2016; @pemstein_democraticcompromiselatent_2017] instead of Polity to minimize missing values for the regime type control variable.

First, the partialling out score function computes the residuals from a regression of the dependent variable on the control variables then a regression of the dependent variable on the independent variables. I then run an OLS of predicting the first stage from the second which creates valid post-selection inference even in cases of imperfect model selection by creating a "second chance" for omitted variables [@belloni_inferencetreatmenteffects_2014].

This is performed on samples generated using 5-fold re-sampling with one repeated sample split. The models are cross-fit, meaning I first split the sample into an auxiliary and a main and estimate the model on the auxiliary sample then perform the partialling out estimation by OLS on the main sample. I then reverse the two samples and take the average of the results, which prevents overfitting [@chernozhukov_doubledebiasedmachine_2018].

```{r}
#| label: tbl-dml
#| tbl-cap: "Double/debiased machine learning model."
#| fig.position: H

# https://docs.doubleml.org/stable/workflow/workflow.html
library(DoubleML)

# Specify the data and variables for the causal model
df_ml <- data.table::as.data.table(df_m1) |>
  tidyr::drop_na()

dml_data_bonus <- DoubleMLData$new(df_ml,
                                   y_col = "dv",
                                   d_cols = c("strcomp", "hier"),
                                   x_cols = c("demo_udsavg", "dist_maxlog", "dist_contigprop", "rivals_log", "members_log", "allianceage_avg", "year_norm", "year_sq", "year_cube"))

library(mlr3)
library(mlr3learners)
lgr::get_logger("mlr3")$set_threshold("warn")

learner <- lrn("regr.ranger",
               num.trees = 500,
               max.depth = 5,
               min.node.size = 2)

ml_l_bonus <- learner$clone()
ml_m_bonus <- learner$clone()

set.seed(3141)
obj_dml_plr_bonus <- DoubleMLPLR$new(dml_data_bonus,
                                     ml_l = ml_l_bonus,
                                     ml_m = ml_m_bonus)
obj_dml_plr_bonus$fit()

ti <- data.frame(term = c("Strategic compatibility", "Hierarchy"),
                 estimate = obj_dml_plr_bonus$coef,
                 std.error = obj_dml_plr_bonus$se,
                 p.value = obj_dml_plr_bonus$pval)

gl <- data.frame(score = obj_dml_plr_bonus$score,
                 "n-folds" = obj_dml_plr_bonus$n_folds,
                 "cross-fitting" = obj_dml_plr_bonus$apply_cross_fitting)

mod <- list(tidy = ti,
            glance = gl)
class(mod) <- "modelsummary_list"

modelsummary::modelsummary(mod,
                           stars = c('*' = .05, '**' = .01, '***' = 0.001))
```

\newpage

# Works Cited
